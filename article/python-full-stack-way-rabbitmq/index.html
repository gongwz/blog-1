<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件。RabbitMQ服务器是用Erlang语言编写的，它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全，RabbitMQ官网，RabbitMQ中文文档。 安装RabbitMQ安装EPEL源 [root@anshengme ~]# yum -y install epel-release 安装erlan">
<meta name="keywords" content="安生,Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python全栈之路系列之RabbitMQ">
<meta property="og:url" content="https://blog.ansheng.me/article/python-full-stack-way-rabbitmq/index.html">
<meta property="og:site_name" content="Welcome to ansheng’s blog!">
<meta property="og:description" content="RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件。RabbitMQ服务器是用Erlang语言编写的，它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全，RabbitMQ官网，RabbitMQ中文文档。 安装RabbitMQ安装EPEL源 [root@anshengme ~]# yum -y install epel-release 安装erlan">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://blog.ansheng.me/images/2016/12/1483068957.png">
<meta property="og:image" content="https://blog.ansheng.me/images/2016/12/1483069006.png">
<meta property="og:image" content="https://blog.ansheng.me/images/2016/12/1483069041.png">
<meta property="og:image" content="https://blog.ansheng.me/images/2016/12/1483069085.png">
<meta property="og:updated_time" content="2018-07-27T03:26:40.079Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python全栈之路系列之RabbitMQ">
<meta name="twitter:description" content="RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件。RabbitMQ服务器是用Erlang语言编写的，它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全，RabbitMQ官网，RabbitMQ中文文档。 安装RabbitMQ安装EPEL源 [root@anshengme ~]# yum -y install epel-release 安装erlan">
<meta name="twitter:image" content="https://blog.ansheng.me/images/2016/12/1483068957.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
          
        
    
    <!-- title -->
    <title>Python全栈之路系列之RabbitMQ</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg active"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg active"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu" style="visibility: visible;">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="//notes.ansheng.me">Notes</a></li>
         
          <li><a href="/article/python-full-stack-way/">PythonFullStackWay</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/article/python-full-stack-way-recursion/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/article/python-full-stack-way-object-oriented-basis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
    </span>
    <br/>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装RabbitMQ"><span class="toc-number">1.</span> <span class="toc-text">安装RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pika"><span class="toc-number">2.</span> <span class="toc-text">pika</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Work-Queues"><span class="toc-number">3.</span> <span class="toc-text">Work Queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化"><span class="toc-number">4.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息公平分发"><span class="toc-number">5.</span> <span class="toc-text">消息公平分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息传输类型"><span class="toc-number">6.</span> <span class="toc-text">消息传输类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#direct-关键字"><span class="toc-number">6.1.</span> <span class="toc-text">direct(关键字)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic-模糊匹配"><span class="toc-number">6.2.</span> <span class="toc-text">topic(模糊匹配)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC-Remote-procedure-call"><span class="toc-number">7.</span> <span class="toc-text">RPC(Remote procedure call)</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Python全栈之路系列之RabbitMQ
    </h1>



    <div class="meta">
      <span class="postdate">创建日期：</span>

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件。RabbitMQ服务器是用Erlang语言编写的，它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全，<a href="https://www.rabbitmq.com" target="_blank" rel="noopener">RabbitMQ官网</a>，<a href="http://rabbitmq.mr-ping.com/" target="_blank" rel="noopener">RabbitMQ中文文档</a>。</p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>安装EPEL源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]<span class="comment"># yum -y install epel-release</span></span><br></pre></td></tr></table></figure>
<p>安装erlang</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]<span class="comment"># yum -y install erlang</span></span><br></pre></td></tr></table></figure>
<p>安装RabbitMQ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]# yum -y install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>启动并设置开机器启动</p>
<p>在启动<code>RabbitMQ</code>之前需要hostname的解析，要不然启动不起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 anshengme</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]<span class="comment"># systemctl start rabbitmq-server</span></span><br><span class="line">[root@anshengme ~]<span class="comment"># systemctl enable rabbitmq-server</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/rabbitmq-server.service to /usr/lib/systemd/system/rabbitmq-server.service.</span><br></pre></td></tr></table></figure>
<p>查看启动状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@anshengme ~]<span class="comment"># netstat -tulnp |grep 5672</span></span><br><span class="line">tcp        0      0 0.0.0.0:25672           0.0.0.0:*               LISTEN      37507/beam.smp      </span><br><span class="line">tcp6       0      0 :::5672                 :::*                    LISTEN      37507/beam.smp</span><br></pre></td></tr></table></figure>
<h2 id="pika"><a href="#pika" class="headerlink" title="pika"></a>pika</h2><p><code>pika</code>模块是官方认可的操作<code>RabbitMQ</code>的API接口。</p>
<p>安装pika</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pika</span><br></pre></td></tr></table></figure>
<p>pika：<a href="https://pypi.python.org/pypi/pika" target="_blank" rel="noopener">https://pypi.python.org/pypi/pika</a></p>
<p>测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pika</span><br></pre></td></tr></table></figure>
<h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>如果你启动了多个消费者，那么生产者生产的任务会根据顺序的依次让消费者来执行，这就是<code>Work Queues</code>模式</p>
<p><img src="/images/2016/12/1483068957.png" alt="rabbitmq-work-queues"></p>
<p>生产者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _*_ codin:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到RabbitMQ 这是一个阻塞的连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'192.168.56.100'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个管道</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过管道创建一个队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在队列内发送数据，body内容，routing_key队列，exchange交换器，通过交换器往hello队列内发送Hello World!数据</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">''</span>, routing_key=<span class="string">'hello'</span>, body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>消费者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _*_ codin:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到RabbitMQ 这是一个阻塞的连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'192.168.56.100'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个管道</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果消费者连接到这个队列的时候，队列没有生成，那么消费者就生成这个队列，如果这个队列已经生成了，那么就忽略它</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] Received %r"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费，当收到hello队列的消息的时候就，就调用callback函数，no_ack消费者在处理任务的时候要不需要确认任务已经处理完成，改为False则要确认</span></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'hello'</span>, no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始接受任务，阻塞</span></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>队列持久化</p>
<p>试想，如果我们的消费者在执行任务执行到一半时，突然down掉了，我们可以更改<code>no_ack=False</code>来让消费者每次执行完成完成之后确认执行完毕了再把这个任务在队列中移除移除掉，但是如果RabbitMQ的服务器停止我们的任务仍然会丢失。</p>
<p>首先，我们需要确保的<code>RabbitMQ</code>永远不会在我们的队列中失去，为了做到这一点，我们需要把<code>durable=True</code>，声明一个新名称的队列，为<code>task_queue</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p><code>durable</code>需要在生产者和消费者上面都需要写上，且<code>durable</code>只会让我们的队列持久化，并不能够让消息持久化。</p>
<p>消息持久化</p>
<p>消息持久化只需要在添加消息的时候添加一个<code>delivery_mode=2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                      routing_key=<span class="string">'world'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          <span class="comment"># 2=消息持久化</span></span><br><span class="line">                          delivery_mode=<span class="number">2</span>,</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>
<p>在消费者的callback函数内添加以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ch.basic_ack(delivery_tag = method.delivery_tag)</span><br></pre></td></tr></table></figure>
<h2 id="消息公平分发"><a href="#消息公平分发" class="headerlink" title="消息公平分发"></a>消息公平分发</h2><p>每一个消费者同时只处理一个任务，比如说现在有三个消费者，刚开始来了三个任务，平均分配给了三个消费者，那么这三个消费者目前都在同时执行任务，当第四个任务到来的时候依旧会分配给第一个消费者，第五个任务到来的时候会分配给第二个消费者，以此类推。</p>
<p>那么以上的状况有什么不妥呢？譬如说不同的消费者执行任务的时间不同，我们现在需要的时候，当三个消费者都在执行任务的时候，比如说第二个消费者任务执行完了，其他消费者都还在执行任务，当第四个任务到来的时候希望交给第二个消费者，若要实现此功能，只需要在消费者加上一下代码即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>完整的代码如下</p>
<p>消费者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</span><br><span class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] Received %r"</span> % body)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">" [x] Done"</span>)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=<span class="string">'task_queue'</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>生产者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    message = <span class="string">"Hello World! %s"</span> % (n + <span class="number">1</span>)</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=<span class="string">'task_queue'</span>,</span><br><span class="line">                          body=message,</span><br><span class="line">                          properties=pika.BasicProperties(</span><br><span class="line">                              delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></span><br><span class="line">                          ))</span><br><span class="line">    print(<span class="string">" [x] Sent %r"</span> % message)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h2 id="消息传输类型"><a href="#消息传输类型" class="headerlink" title="消息传输类型"></a>消息传输类型</h2><p>之前的例子都基本都是1对1的消息发送和接收，即消息只能发送到指定的queue里，但有些时候你想让你的消息被所有的Queue收到，类似广播的效果，这时候就要用到exchange了，</p>
<p>Exchange在定义的时候是有类型的，以决定到底是哪些Queue符合条件，可以接收消息</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fanout</code></td>
<td style="text-align:left">所有bind到此exchange的queue都可以接收消息</td>
</tr>
<tr>
<td style="text-align:left"><code>direct</code></td>
<td style="text-align:left">通过routingKey和exchange决定的那个唯一的queue可以接收消息</td>
</tr>
<tr>
<td style="text-align:left"><code>topic</code></td>
<td style="text-align:left">所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息</td>
</tr>
</tbody>
</table>
<p>fanout(发布订阅)</p>
<p>只要有消费者，那么我生产者发布一条消息的时候所有的消费者都会被收到</p>
<p><img src="/images/2016/12/1483069006.png" alt="rabbitmq-fanout"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"><span class="comment"># 不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 获取queue的name</span></span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"><span class="comment"># 把queue绑定到exchange</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'logs'</span>, queue=queue_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r"</span> % body)</span><br><span class="line">channel.basic_consume(callback,queue=queue_name,no_ack=<span class="keyword">True</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># fanout发送给所有人</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">'logs'</span>, routing_key=<span class="string">''</span>, body=<span class="string">"Hello World!"</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<h3 id="direct-关键字"><a href="#direct-关键字" class="headerlink" title="direct(关键字)"></a>direct(关键字)</h3><p>RabbitMQ还支持根据关键字发送，即：队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。</p>
<p><img src="/images/2016/12/1483069041.png" alt="rabbitmq-direct"></p>
<p>生产者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                         type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'info'</span></span><br><span class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">'Hello World!'</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                      routing_key=severity,</span><br><span class="line">                      body=message)</span><br><span class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>消费者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                         type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> severities:</span><br><span class="line">    sys.stderr.write(<span class="string">"Usage: %s [info] [warning] [error]\n"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="topic-模糊匹配"><a href="#topic-模糊匹配" class="headerlink" title="topic(模糊匹配)"></a>topic(模糊匹配)</h3><p>在topic类型下，可以让队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入”路由值“和 ”关键字“进行匹配，匹配成功，则将数据发送到指定队列。</p>
<p><strong>表达式符号说明：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>#</code></td>
<td style="text-align:left">表示可以匹配<code>0个</code>或<code>多个</code>单词</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">表示只能匹配<code>一个</code>单词</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">发送者路由值</th>
<th style="text-align:left">队列中</th>
<th style="text-align:left">是否匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ansheng.me</td>
<td style="text-align:left">ansheng.*</td>
<td style="text-align:left">不匹配</td>
</tr>
<tr>
<td style="text-align:left">ansheng.me</td>
<td style="text-align:left">ansheng.#</td>
<td style="text-align:left">匹配</td>
</tr>
</tbody>
</table>
<p>消费者代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>,</span><br><span class="line">                         type=<span class="string">'topic'</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</span><br><span class="line">    sys.stderr.write(<span class="string">"Usage: %s [binding_key]...\n"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'topic_logs'</span>,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=binding_key)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>生产者代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>,</span><br><span class="line">                         type=<span class="string">'topic'</span>)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'anonymous.info'</span></span><br><span class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">'Hello World!'</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'topic_logs'</span>,</span><br><span class="line">                      routing_key=routing_key,</span><br><span class="line">                      body=message)</span><br><span class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (routing_key, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="RPC-Remote-procedure-call"><a href="#RPC-Remote-procedure-call" class="headerlink" title="RPC(Remote procedure call)"></a>RPC(Remote procedure call)</h2><p>客户端发送一个任务到服务端，服务端把任务的执行结果再返回给客户端</p>
<p><img src="/images/2016/12/1483069085.png" alt="rabbitmq-rpc"></p>
<ul>
<li>RPC Server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 声明一个RPC QUEUE</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'rpc_queue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_request</span><span class="params">(ch, method, props, body)</span>:</span></span><br><span class="line">    <span class="comment"># 接受传过来的值</span></span><br><span class="line">    n = int(body)</span><br><span class="line">    print(<span class="string">" [.] fib(%s)"</span> % n)</span><br><span class="line">    <span class="comment"># 交给fib函数进行斐波那契处理</span></span><br><span class="line">    response = fib(n)</span><br><span class="line">    <span class="comment"># 把结果发回去，此时消费者变成生产者</span></span><br><span class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                     routing_key=props.reply_to,</span><br><span class="line">                     <span class="comment"># 客户端传过来的UUID顺便发回去</span></span><br><span class="line">                     properties=pika.BasicProperties(correlation_id=props.correlation_id),</span><br><span class="line">                     body=str(response))</span><br><span class="line">    <span class="comment"># 持久化</span></span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时只处理一个任务</span></span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line">channel.basic_consume(on_request, queue=<span class="string">'rpc_queue'</span>)</span><br><span class="line">print(<span class="string">" [x] Awaiting RPC requests"</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>RPC Client</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciRpcClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">            host=<span class="string">'192.168.56.100'</span>))</span><br><span class="line"></span><br><span class="line">        self.channel = self.connection.channel()</span><br><span class="line"></span><br><span class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># 服务端返回处理完毕的数据新Queue名称</span></span><br><span class="line">        self.callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">        self.channel.basic_consume(self.on_response, no_ack=<span class="keyword">True</span>,</span><br><span class="line">                                   queue=self.callback_queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></span><br><span class="line">        <span class="comment"># corr_id等于刚刚发送过去的ID，就代表这条消息是我的</span></span><br><span class="line">        <span class="keyword">if</span> self.corr_id == props.correlation_id:</span><br><span class="line">            self.response = body</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.response = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 生成一个唯一ID，相当于每个任务的ID</span></span><br><span class="line">        self.corr_id = str(uuid.uuid4())</span><br><span class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                                   routing_key=<span class="string">'rpc_queue'</span>,</span><br><span class="line">                                   properties=pika.BasicProperties(</span><br><span class="line">                                       <span class="comment"># 让服务端处理完成之后把数据放到这个Queue里面</span></span><br><span class="line">                                       reply_to=self.callback_queue,</span><br><span class="line">                                       <span class="comment"># 加上一个任务ID</span></span><br><span class="line">                                       correlation_id=self.corr_id,</span><br><span class="line">                                   ),</span><br><span class="line">                                   body=str(n))</span><br><span class="line">        <span class="keyword">while</span> self.response <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># 不断地去Queue接受消息，但不是阻塞的，而是一直循环的去取</span></span><br><span class="line">            self.connection.process_data_events()</span><br><span class="line">        <span class="keyword">return</span> int(self.response)</span><br><span class="line"></span><br><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line">print(<span class="string">" [x] Requesting fib(30)"</span>)</span><br><span class="line">response = fibonacci_rpc.call(<span class="number">30</span>)</span><br><span class="line">print(<span class="string">" [.] Got %r"</span> % response)</span><br></pre></td></tr></table></figure>
  </div>
</article>
<div style="text-align:center">
  <hr>
  <img src="/images/wechat.jpg" alt="wechat" style="width:450px;">
</div>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="//notes.ansheng.me">Notes</a></li>
         
          <li><a href="/article/python-full-stack-way/">PythonFullStackWay</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装RabbitMQ"><span class="toc-number">1.</span> <span class="toc-text">安装RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pika"><span class="toc-number">2.</span> <span class="toc-text">pika</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Work-Queues"><span class="toc-number">3.</span> <span class="toc-text">Work Queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化"><span class="toc-number">4.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息公平分发"><span class="toc-number">5.</span> <span class="toc-text">消息公平分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息传输类型"><span class="toc-number">6.</span> <span class="toc-text">消息传输类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#direct-关键字"><span class="toc-number">6.1.</span> <span class="toc-text">direct(关键字)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic-模糊匹配"><span class="toc-number">6.2.</span> <span class="toc-text">topic(模糊匹配)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC-Remote-procedure-call"><span class="toc-number">7.</span> <span class="toc-text">RPC(Remote procedure call)</span></a></li></ol>
    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 ansheng
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="//notes.ansheng.me">Notes</a></li>
         
          <li><a href="/article/python-full-stack-way/">PythonFullStackWay</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-89592236-1', 'auto');
        ga('send', 'pageview');
    </script>


<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'blog-ansheng-me';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


